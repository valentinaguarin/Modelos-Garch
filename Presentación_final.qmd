---
title: "Modelos GARCH multivariados para el cálculo de valor en riesgo de un portafolio de activos financieros utilizando R y Python"
author:
- name: "José Manuel Pérez Pérez"
  affiliation: "Universidad Nacional de Colombia Sede Medellín"
- name: "Valentina Tamayo Guarín"
date: last-modified
filters:
   - lightbox
lightbox: auto
format:
  html:
    theme: cerulean
    page-layout: full
    toc: true
    toc-title: Contenido
    toc-location: left
    code-copy: true
    code-fold: true
    code-tools:
      source: false
      toggle: true
      caption: none
    smooth-scroll: true
--- 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, warning = FALSE, message = FALSE, fig.align = "center", out.width="80%", fig.height=5, fig.width = 8)

```

# Introducción

![](figs/invertir.png){fig-alt="Gráfico de inversión para diferentes tipos de rentas." fig-align="center" width=60%}

::: callout-tip
# Objetivo Principal
Analizar la aplicabilidad de los modelos GARCH multivariados en el cálculo del Valor en Riesgo (VaR) de activos financieros mediante el uso de los software R y Python.
:::


# Obtención series de tiempo

::: panel-tabset

## Librerías

Las librerías necesarias para realizar todo el proceso de análisis de series financieras se muestran a continuación:

```{r}
library(tidyverse)  # Manejo de datos.
library(magrittr)   # Simplificación del código (pipes).
library(janitor)    # Limpieza y normalización de datos.
library(ggplot2)    # Visualización de datos.
library(gridExtra)  # Combinación de gráficos.
library(gganimate)  # Animación de gráficos.
library(kableExtra) # Creaciónde tablas 
library(quantmod)   # Análisis financiero y visualización de datos financieros.
library(TSstudio)   # Análisis descriptivo y predictivo de datos de series temporales
library(tseries)    # Análisis de series de tiempo.
library(rugarch)    # Modelado de volatilidad financiera.
library(forecast)   # Pronóstico de series de tiempo.
library(reticulate) # Integración de Python en R.
library(imputeTS)   # Imputación de datos de una serie de tiempo.
library(PerformanceAnalytics) # Análisis de rendimiento(retorno) financiero.
library(gogarch)    # Ajustar modelos GARCH.
library(plotly)     # Para crear gráficos interactivos.
library(timetk)     # Para manipular la serie de datos.
library(gifski)     # Creación de imágenes animadas.
```

## Obtención datos desde yahoo finance

![](figs/sectores.png){fig-alt="Sectores de sistema del mercado nacional." fig-align="center" width=60%}

```{r}
# Fecha de extracción series de tiempo
startDate <- as.Date("2015-01-01") # Fecha de inicio
endDate <- as.Date("2022-01-01") # Fecha de fin

# Obtener datos desde yahoo finance

symbol_name <- c('AMZN', 'AAPL', 'MSFT', 'TSLA',
                 'META','DIS','NFLX','NVDA')

actions <- getSymbols(symbol_name, from = startDate, to = endDate,
                      src = 'yahoo',periodicity="daily")%>%
  map(~Cl(get(.))) %>%
  purrr::reduce(merge) %>% clean_names() 
```


```{r}
#| echo: false
# Convertir a data frame acciones juntas
actions_dat <- as.data.frame(actions) 
# Agregar fecha
actions_dat$fecha <-as.Date(rownames(actions_dat)) 
# Resetear indice
rownames(actions_dat) <- rownames(1:length(actions_dat))


# Organizar data frame
actions_dat <- actions_dat %>% 
  dplyr::select(fecha,amzn_close,aapl_close,
         msft_close,tsla_close,
         meta_close,dis_close,
         nflx_close,nvda_close)

# acciones estandarizadas juntas (xts)
actions_std <- scale(actions) 

# Convertir a data frame acciones estandariazadas juntas
actions_std_dat <- as.data.frame(actions_std) 
# Agregar fecha
actions_std_dat$fecha <-as.Date(rownames(actions_std_dat)) 
# Resetear indice
rownames(actions_std_dat) <- rownames(1:length(actions_std_dat))
```


```{r}
#| echo: false

tabla_actions_dat<-actions_dat
colnames(tabla_actions_dat)<- c("Fecha", "Amazon Close","Apple Close" ,"Microsoft Close", "Tesla Close", "Meta Close", "Disney Close","Netflix Close","Nvidia Close")

form.basic=c("striped","bordered","hover","condensed","responsive")

kable(tabla_actions_dat %>% head(4),
  caption = "Encabezado del precio de cierre de las acciones") %>%
   kable_styling(bootstrap_options =form.basic )

```
:::

```{r}
#| echo: false
# actions %<>% na.omit()
# actions_dat %<>% na.omit()
# actions_std_dat %<>% na.omit()
```


<!-- # Acciones ordinarias y preferenciales -->

<!-- :::: {.columns} -->

<!-- ::: {.column width="50%"} -->
<!-- ::: callout-tip -->
<!-- ## ¿Sabes que es una acción ordinaria? -->

<!-- Una acción ordinaria es una acción que se puede negociar en el mercado y que representa una parte proporcional del capital social de una empresa. -->
<!-- ::: -->
<!-- ::: -->

<!-- ::: {.column width="50%"} -->
<!-- ::: callout-tip -->
<!-- ## ¿Sabes que es una acción preferencial? -->

<!-- Una acción preferencial es una acción que confiere a su titular un privilegio extra, generalmente de tipo económico, con respecto a lo que comúnmente conocemos como acción ordinaria. -->
<!-- ::: -->
<!-- ::: -->

<!-- :::: -->


<!-- ::: panel-tabset -->

<!-- ## ¿Cual es la diferencia entre las acciones y las acciones preferenciales? -->

<!-- ![](figs/Cuadro Comparativo Acciones.jpg){fig-alt="Cuadro comparativo entre las acciones ordinarias y las preferenciales." fig-align="center" width=70%} -->

<!-- ## Ejemplo -->

<!-- ```{r} -->
<!-- #| echo: false -->
<!-- symbol_name_2 <- c("BCOLOMBIA.CL","GRUPOAVAL.CL","PFBCOLOM.CL","PFAVAL.CL") -->

<!-- financial <- getSymbols(symbol_name_2, from = startDate, to = endDate, -->
<!--                         src = 'yahoo',periodicity="daily")%>% -->
<!--   map(~Cl(get(.))) %>% -->
<!--   purrr::reduce(merge) %>% clean_names() -->


<!-- # Convertir a data frame sector financiero -->
<!-- financial_dat <- as.data.frame(financial)  -->
<!-- # Agregar fecha -->
<!-- financial_dat$fecha <-as.Date(rownames(financial_dat))  -->
<!-- # Resetear indice -->
<!-- rownames(financial_dat) <- rownames(1:length(financial_dat)) -->
<!-- # Organizar data frame -->
<!-- financial_dat <- financial_dat %>%  -->
<!--   dplyr::select(fecha,bcolombia_cl_close, -->
<!--          pfbcolom_cl_close,grupoaval_cl_close, -->
<!--          pfaval_cl_close) # organizar data frame -->
<!-- ``` -->


<!-- **Bancolombia** -->
<!-- ```{r} -->
<!-- #| echo: false -->

<!-- # Muestra el encabezado de cada base de datos -->

<!-- tabla_datos_ban<-financial_dat[,1:3] -->
<!-- colnames(tabla_datos_ban)<- c("Fecha", "Bancolombia Ord Close","Bancolombia Pref Close") -->

<!-- form.basic=c("striped","bordered","hover","condensed","responsive") -->

<!-- kable(tabla_datos_ban %>% head(4), -->
<!--   caption = "Encabezado del precio de cierre de las acciones ordinarias y preferenciales de Bancolombia") %>% -->
<!--    kable_styling(bootstrap_options =form.basic ) -->
<!-- ``` -->

<!-- **Grupo Aval** -->
<!-- ```{r} -->
<!-- #| echo: false -->
<!-- # Muestra el encabezado de cada base de datos -->

<!-- tabla_datos_aval<-financial_dat[,c(1,4,5)] -->
<!-- colnames(tabla_datos_aval)<- c("Fecha", "Grupo Aval Ord Close","Grupo Aval Pref Close") -->

<!-- form.basic=c("striped","bordered","hover","condensed","responsive") -->

<!-- kable(tabla_datos_aval %>% tail(4), -->
<!--   caption = "Cola del precio de cierre de las acciones ordinarias y preferenciales del Grupo Aval") %>% -->
<!--    kable_styling(bootstrap_options =form.basic ) -->

<!-- ``` -->

<!-- **Gráficos acciones ordinarias vs preferenciales** -->
<!-- ```{r} -->
<!-- #| echo: false -->
<!-- #| cache: true -->
<!-- #| layout-ncol: 2 -->
<!-- #| lightbox:  -->
<!-- #|   group: Acciones ordinarias vs preferenciales -->
<!-- #|   description:  -->
<!-- #|     - Se puede observar que casi no existe diferencias entre estos dos tipos de acciones. -->
<!-- #|     - Se puede observar que casi no existe diferencias entre estos dos tipos de acciones. -->

<!-- graf_ban<-ggplot(financial_dat, aes(x=fecha)) + -->
<!--   geom_line( aes(y=bcolombia_cl_close)) +  -->
<!--   geom_line( aes(y=pfbcolom_cl_close), size=0.5, color= "red") + -->
<!--   scale_y_continuous( -->

<!--     # Features of the first axis -->
<!--     name = "Bancolombia ordinaria" , -->

<!--     # Add a second axis and specify its features -->
<!--     sec.axis = sec_axis(~.*1, name=" Preferencial Bancolombia"))+ -->
<!--     labs(title="Acciones Bancolombia")+ -->
<!--     theme(plot.title = element_text(color="black", size=16, face="bold.italic", hjust=0.5)) -->

<!-- graf_ban + transition_reveal(fecha) -->

<!-- graf_aval<-ggplot(financial_dat, aes(x=fecha)) + -->
<!--   geom_line( aes(y=grupoaval_cl_close)) +  -->
<!--   geom_line( aes(y=pfaval_cl_close), size=0.5, color="red" ) + -->
<!--   scale_y_continuous( -->

<!--     # Features of the first axis -->
<!--     name = "Grupo aval ordinaria" , -->

<!--     # Add a second axis and specify its features -->
<!--     sec.axis = sec_axis(~.*1, name=" Preferencial Grupo aval"))+ -->
<!--     labs(title="Acciones Grupo Aval")+ -->
<!--     theme(plot.title = element_text(color="black", size=16, face="bold.italic", hjust=0.5)) -->

<!-- graf_aval -->
<!-- ``` -->
<!-- ::: -->


# Series de tiempo

::: panel-tabset

### Acciones

```{r}
#| echo: false


 ts_plot(actions_dat,
         slider = T, type = "single",
         width = 1,
         title = "Acciones NMS", Xgrid = T, Ygrid = T)


# Transformar los datos en formato largo (long format)
#  datos_long <- actions_std_dat %>%
#    pivot_longer(cols = -fecha, names_to = "serie", values_to = "valor")
#
#  # Crear el gráfico interactivo con múltiples series de tiempo
#  grafico <- plot_ly(datos_long, x = ~fecha, y = ~valor, color = ~serie,
#                     type = "scatter", mode = "lines") %>%
#    layout(title = "Gráfico interactivo de series de tiempo",
#          xaxis = list(title = "Fecha"),
#           yaxis = list(title = "Valor"))
#
# # # Mostrar el gráfico
#  grafico
```


### Acciones 1
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Precio de cierre acciones 

grafico_serie <- function(datos, y_aes, titulo){
  
  datos %>%
    ggplot(aes(x=fecha, y=y_aes)) +
    geom_line(size=0.5, color="black") +
    ggtitle(titulo) +
    ylab("Precio de cierre")+
    xlab("Fecha") + 
    theme(plot.title = element_text(color="#15297c", size=14, face="bold.italic", hjust=0.5))
}

f1 <- grafico_serie(na.omit(actions_dat[,c(2,1)]),
                    na.omit(actions_dat$amzn_close),
                    "Serie de tiempo precio de las acciones de Amazon")
f1 + transition_reveal(fecha)

f2 <- grafico_serie(na.omit(actions_dat[,c(3,1)]),
                    na.omit(actions_dat$aapl_close),
                    "Serie de tiempo precio de las acciones de Apple")
f2


f3 <- grafico_serie(na.omit(actions_dat[,c(4,1)]),
                    na.omit(actions_dat$msft_close),
                    "Serie de tiempo precio de las acciones de Microsoft")
f3

f4 <- grafico_serie(na.omit(actions_dat[,c(5,1)]),
                    na.omit(actions_dat$tsla_close),
                    "Serie de tiempo precio de las acciones de Tesla")
f4
```

### Acciones 2
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Precio de cierre acciones 

f5 <- grafico_serie(na.omit(actions_dat[,c(6,1)]),
                    na.omit(actions_dat$meta_close),
                    "Serie de tiempo precio de las acciones de Meta")
f5 + transition_reveal(fecha)

f6 <- grafico_serie(na.omit(actions_dat[,c(7,1)]),
                    na.omit(actions_dat$dis_close),
                    "Serie de tiempo precio de las acciones de Disney")
f6

f7 <- grafico_serie(na.omit(actions_dat[,c(8,1)]),
                    na.omit(actions_dat$nflx_close),
                    "Serie de tiempo precio de las acciones de Netflix")
f7

f8 <- grafico_serie(na.omit(actions_dat[,c(9,1)]),
                    na.omit(actions_dat$nvda_close),
                    "Serie de tiempo precio de las acciones de Nvidia")
f8
```
:::

# Retornos
```{r}
#| echo: false

## Acciones juntas
actions_dat_return <- Return.calculate(actions_dat,method="log") %>% na.omit # calcular retornos data frame

actions_return <- Return.calculate(actions,method="log") %>% na.omit() # calcular retornos xts

actions_dat_return$fecha <-as.Date(rownames(actions_dat_return)) # agregar fecha

rownames(actions_dat_return) <- rownames(1:length(actions_dat_return)) # resetear indice

```

## Retorno simple

$$R_t =\frac{y_t-y_{t-1}}{y_{t-1}}$$

::: callout-tip
## ¿Por qué calcular el retorno?

Este mide la rentabilidad de una inversión. Es la ganancia respecto a una inversión durante un periodo de tiempo.

se pueden entender como:

- El porcentaje de aumento o disminución en relación con el día anterior.

- Los retornos también son un indicador de que tan estable es el mercado.

:::

## Retornos logarítmicos 

$$r_t=Log\left(\frac{y_t}{y_{t-1}}\right)$$

::: callout-tip
## Ventajas retorno del logaritmo
 
- El logaritmo permite estabilizar la varianza.

- El retorno logarítmico es la suma de los retornos diarios, es decir, son aditivos en el tiempo.

:::

::: panel-tabset

## Retornos 1
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Retornos acciones

# Función gráficos retornos series de tiempo 
graficos_retornos <- function(data,close,titulo){
  
  data %>% 
    ggplot(aes(fecha,close))+
    geom_line(size=0.5, color="black")+
    labs(title= titulo ,y = "Retornos", x = "Fecha")+
    theme(plot.title = element_text(color="#15297c", size=14, face="bold.italic", hjust=0.5))
  
}

r1 <- graficos_retornos(na.omit(actions_dat_return[,c(1,9)]),
                        na.omit(actions_dat_return$amzn_close),
                        "Retornos Amazon" )
r1 

r2 <- graficos_retornos(na.omit(actions_dat_return[,c(2,9)]),
                        na.omit(actions_dat_return$aapl_close),
                        "Retornos Apple" )
r2 

r3 <- graficos_retornos(na.omit(actions_dat_return[,c(3,9)]),
                        na.omit(actions_dat_return$msft_close),
                        "Retornos Microsoft" )
r3 

r4 <- graficos_retornos(na.omit(actions_dat_return[,c(4,9)]),
                        na.omit(actions_dat_return$tsla_close),
                        "Retornos Tesla" )
r4 
```

## Retornos 2
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Retornos acciones 2


r5 <- graficos_retornos(na.omit(actions_dat_return[,c(5,9)]),
                        na.omit(actions_dat_return$meta_close),
                        "Retornos Meta" )
r5 

r6 <- graficos_retornos(na.omit(actions_dat_return[,c(6,9)]),
                        na.omit(actions_dat_return$dis_close),
                        "Retornos Disney" )
r6 

r7 <- graficos_retornos(na.omit(actions_dat_return[,c(7,9)]),
                        na.omit(actions_dat_return$nflx_close),
                        "Retornos Netflix" )
r7 

r8 <- graficos_retornos(na.omit(actions_dat_return[,c(8,9)]),
                        na.omit(actions_dat_return$nvda_close),
                        "Retornos Nvidia" )
r8 
```

## Bandas de confianza
```{r}
#| echo: false
#| cache: true
grafico <- r4 +
  geom_hline(aes(yintercept= 0.10, linetype = "Leve"), colour= 'green',lwd=1) +
  geom_hline(aes(yintercept= 0.15, linetype = "Normal"), colour= 'blue',lwd=1) +
  geom_hline(aes(yintercept= 0.20, linetype = "Critico"), colour= 'red',lwd=1)+
  scale_linetype_manual(name = "Bandas de confianza", values = c(2,2,2),
                        guide = guide_legend(override.aes = list(color =c("red" ,"blue","green"))))+
  geom_hline(yintercept = -0.1, linetype = 2, color = "green", lwd = 1) +
  geom_hline(yintercept = -0.15, linetype = 2, color = "blue", lwd = 1) +
  geom_hline(yintercept = -0.20, linetype = 2, color = "red", lwd = 1)+
  labs(x = "Fecha", 
       y = "Retornos")

grafico
```

**Función conteo de puntos por fuera de las bandas de confianza**
```{r}
## Funcion conteo puntos por fuera de las bandas de confianza
count_confidence_bands <- function(ret,  conf_10 = FALSE, conf_15 = FALSE, conf_20 = FALSE) {
  
  # Calcular los límites de cada banda de confianza
  conf_10 <- c(-0.1, 0.1)
  conf_15 <- c(-0.15, 0.15)
  conf_20 <- c(-0.2, 0.2)
  
  # Contar los puntos fuera de cada banda de confianza
  ret_10 <- ifelse(ret < conf_10[1] | ret > conf_10[2], 1, 0)
  ret_15 <- ifelse(ret < conf_15[1] | ret > conf_15[2], 1, 0)
  ret_20 <- ifelse(ret < conf_20[1] | ret > conf_20[2], 1, 0)
  
  # Crear un data frame con los resultados
  result <- data.frame( ret_10, ret_15, ret_20)
  
  # Agregar las columnas al data frame original
  #ret_df <- data.frame(ret, result)
  
  return(result)
}

ret <- count_confidence_bands(actions_dat_return$tsla_close)
```


```{r}
#| echo: false
tsla_ret <- cbind(actions_dat_return$tsla_close,actions_dat_return$fecha,ret)

colnames(tsla_ret) <- c("Precio de cierre","Fecha","ret_10","ret_15","ret_20") 

tsla_ret_1 <- tsla_ret %>% 
  dplyr::filter(ret_10==1) 
```


```{r}
#| echo: false
# contar la cantidad de un porcentaje de retorno
 tsla_ret %>%
   group_by(ret_10,ret_15,ret_20) %>%
   summarise(n=n()) %>% knitr::kable(caption = "Conteo de puntos por fuera de las bandas de confianza") %>%
   kable_styling(bootstrap_options =form.basic )
```
:::

## Retornos del logaritmo imputados

::: panel-tabset

## Serie imputada Retornos Acciones 1
```{r}
#| echo: false
#| results: hide

# Aplicar función de las bandas 
confidence <- count_confidence_bands(actions_dat_return$amzn_close)
# Juntar datos obtenidos de la funcion
t_1 <- cbind(actions_dat_return$amzn_close,actions_dat_return$fecha,confidence)

# renombrar datos
colnames(t_1) <- c("Precio de cierre","Fecha","ret_10","ret_15","ret_20")

# organizar datos
t_1 <- t_1 %>% dplyr::select("Fecha","Precio de cierre",
                      "ret_10","ret_15","ret_20")
t_2 <- t_1 %>% 
  dplyr::filter(ret_10==1) # comparando 


impute_outliers <- function(ts_name, dates_to_change) {
  
  # Get the time series and remove any outliers
  ts <- na.omit(ts_name)
  #ts <- na.omit(financial_return[[ts_name]])
  
  # Put NA's for the specified dates to change
  for (i in 1:length(dates_to_change)) {
    ts[which(index(ts) == as.Date(dates_to_change[i]))] <- NA
  }
  
  # Impute using exponential moving averages
  ts_imputed <- na_ma(ts, k = 3, weighting = "exponential")
  
  return(ts_imputed)
}



amzn_imputed <- actions_return[,1]

#########---------------------------------------------------------------####


aapl_imputed <- actions_return[,2]


#########---------------------------------------------------------------####


fechas<-c("2020-03-16 ")

msft_imputed <- impute_outliers(actions_return$msft_close,fechas)


########---------------------------------------------------------------####

fechas<-c("2018-08-02","2018-10-01","2019-10-24","2020-02-03","2020-02-05"
          ,"2020-03-16","2020-03-18","2020-03-19","2020-03-24","2020-09-08",
          "2021-03-09")

tsla_imputed <-impute_outliers(actions_return$tsla_close,fechas)




########---------------------------------------------------------------####

fechas<-c("2018-07-26","2020-03-16")

meta_imputed <- impute_outliers(actions_return$meta_close,fechas)


#########---------------------------------------------------------------####


dis_imputed <-  actions_return[,6]


########---------------------------------------------------------------####

fechas<-c("2015-01-21","2015-04-16","2015-07-16","2016-10-18","2021-01-20")

nflx_imputed <-impute_outliers(actions_return$nflx_close,fechas)

#########---------------------------------------------------------------####

fechas<-c("2016-11-11","2017-05-10","2018-11-16","2020-03-16","2020-03-24")

nvda_imputed <-impute_outliers(actions_return$nvda_close,fechas)

```

```{r}
#| echo: false
# Función para convertir a data frame

convert_data_frame <- function(df){
  
  df <- as.data.frame(df)
  df$fecha<- as.Date(rownames(df))
  rownames(df) <- rownames(1:length(df))
  
  return(df)
  
}

amzn_imputed_df <- convert_data_frame(amzn_imputed)

aapl_imputed_df <- convert_data_frame(aapl_imputed)

msft_imputed_df <- convert_data_frame(msft_imputed)

tsla_imputed_df <- convert_data_frame(tsla_imputed)
```

```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Retornos acciones 

imp_1 <- graficos_retornos(amzn_imputed_df,amzn_imputed_df$amzn_close ,"Retornos Amazon")

imp_1
  
imp_2 <- graficos_retornos(aapl_imputed_df,aapl_imputed_df$aapl_close
                  ,"Retornos Apple")
imp_2

imp_3 <- graficos_retornos(msft_imputed_df,
                           msft_imputed_df$msft_close
                  ,"Retornos Microsoft")
imp_3

imp_4 <- graficos_retornos(tsla_imputed_df,
                           tsla_imputed_df$tsla_close
                           ,"Retornos Tesla")
imp_4
```

## Serie imputada Retornos Acciones 2
```{r}
#| echo: false
meta_imputed_df <- convert_data_frame(meta_imputed)

dis_imputed_df <- convert_data_frame(dis_imputed)

nflx_imputed_df <- convert_data_frame(nflx_imputed)

nvda_imputed_df <- convert_data_frame(nvda_imputed)
```

```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Retornos 

imp_5 <- graficos_retornos(meta_imputed_df,meta_imputed_df$meta_close ,"Retornos Meta")
imp_5
  
imp_6 <- graficos_retornos(dis_imputed_df,dis_imputed_df$dis_close
                  ,"Retornos Disney")
imp_6

imp_7 <- graficos_retornos(nflx_imputed_df,nflx_imputed_df$nflx_close
                  ,"Retornos Netflix")
imp_7

imp_8 <- graficos_retornos(nvda_imputed_df,nvda_imputed_df$nvda_close,"Retornos Nvidia")
imp_8
```


## Bandas de confianza serie imputada
```{r}
#| echo: false
grafico_1 <- imp_4 +
  geom_hline(aes(yintercept= 0.10, linetype = "Leve"), colour= 'green',lwd=1) +
  geom_hline(aes(yintercept= 0.15, linetype = "Normal"), colour= 'blue',lwd=1) +
  geom_hline(aes(yintercept= 0.20, linetype = "Critico"), colour= 'red',lwd=1)+
  scale_linetype_manual(name = "Bandas de confianza", values = c(2,2,2),
                        guide = guide_legend(override.aes = list(color =c("red" ,"blue","green"))))+
  geom_hline(yintercept = -0.1, linetype = 2, color = "green", lwd = 1) +
  geom_hline(yintercept = -0.15, linetype = 2, color = "blue", lwd = 1) +
  geom_hline(yintercept = -0.20, linetype = 2, color = "red", lwd = 1)+
  labs(x = "Fecha", 
       y = "Retornos")

grafico_1
```
:::

# Modelos GARCH

## Marco Teórico

El modelo GARCH fue introducido por primera vez por Robert F. Engle en 1982. El modelo se basa en la idea de que la varianza de una serie temporal financiera se puede modelar como una combinación lineal de los errores pasados de la serie, junto con la varianza de la serie en el período anterior.


![](figs/robert-engle.jpg){fig-alt="Fotografía de Robert F. Engle (1942- Actualidad)." fig-align="center" width=30%}

Los modelos GARCH ( Generalized Autoregressive Conditional Heteroscedasticity) son una clase de modelos econométricos que se utilizan para modelar la volatilidad de una serie temporal financiera. A diferencia de los modelos tradicionales que asumen que la varianza es constante, los modelos GARCH permiten que la varianza cambie con el tiempo. Esto es importante en el análisis financiero, ya que la volatilidad puede ser un factor clave en la toma de decisiones de inversión.


::: callout-tip
# En resumen
El modelo GARCH es una herramienta importante para modelar la volatilidad en series de tiempo financieras, lo que puede ayudar a los inversores a tomar decisiones informadas y a los analistas financieros a comprender mejor las dinámicas del mercado.
:::

## Modelo Estadístico

El modelo GARCH se compone de dos partes: el modelo generalizado (G) y el modelo heteroscedástico condicional autoregresivo (ARCH). El modelo AR se basa en la idea de que la varianza en un período de tiempo depende de la varianza en el período anterior y de los errores de predicción pasados. El modelo ARCH se basa en la idea de que la varianza puede cambiar en función de factores externos y eventos del mercado.
$$
\Huge \varepsilon_t \mid {\color{Olive}\mathbf{\Psi}_{t-1}} \sim \mathrm{N}\left(0, \sigma_t^2\right)
$$


$$
\Huge
\sigma_t^2=\alpha_0+\sum_{i=1}^q {\color{red}\alpha_i \epsilon_{t-i}^2}+\sum_{j=1}^p {\color{blue}\beta_j\sigma_{t-j}^2}
$$

## Paquetes en R 

![](figs/paquetes.png){fig-alt="Paquetes disponibles en R para trabajar con modelos GARCH" fig-align="center" width=60%}

## Modelamiento de la variabilidad de las acciones
```{r}
#| echo: false
#| results: hide
#| cache: true

##--------------Auto arima-----------------##
## auto arima

arima_intervalo <- function(datos) {
  auto <- auto.arima(datos, stepwise = FALSE, approximation = FALSE, ic = c("aic"))
  intervalo <- qnorm(0.975) * sqrt(auto$sigma2)
  
  resultado <- list(
    modelo = auto,
    li = -intervalo,
    ls = intervalo
  )
  
  return(resultado)
}

arima_amazon <- arima_intervalo(amzn_imputed)

arima_apple <- arima_intervalo(aapl_imputed)

arima_microsoft <- arima_intervalo(msft_imputed)

arima_tesla <- arima_intervalo(tsla_imputed)

arima_meta <- arima_intervalo(meta_imputed)

arima_disney <- arima_intervalo(dis_imputed)

arima_netflix <- arima_intervalo(nflx_imputed)

arima_nvidia <- arima_intervalo(nvda_imputed)

```

```{r}
#| echo: false
#| results: hide
#| cache: true
#| 
##-------------- GARCH -----------------##

##--Cemargos--##
## garch

garch_intervalo <- function(datos) {
  library(rugarch)
  
  # Especificación del modelo GARCH(1, 1)
  espec <- ugarchspec(variance.model = list(garchOrder = c(1, 1)))
  
  # Ajuste del modelo GARCH a los datos
  modelo <- ugarchfit(spec = espec, data = datos)
  
  # Cálculo del intervalo de confianza
  intervalo <- qnorm(0.975) * modelo@fit$sigma
  
  resultado <- list(
    modelo = modelo,
    li = -intervalo,
    ls = intervalo
  )
  
  return(resultado)
}

garch_amazon <- garch_intervalo(amzn_imputed)

garch_apple <- garch_intervalo(aapl_imputed)

garch_microsoft <- garch_intervalo(msft_imputed)

garch_tesla <- garch_intervalo(tsla_imputed)

garch_meta <- garch_intervalo(meta_imputed)

garch_disney <- garch_intervalo(dis_imputed)

garch_netflix <- garch_intervalo(nflx_imputed)

garch_nvidia <- garch_intervalo(nvda_imputed)


```

::: panel-tabset

## Varianza constante

**Retornos Acciones 1**
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Modelamiento varianza constante 

grafico_varianza_constante <- function(data, y, y_intercept, title) {
  
  ggplot(data, aes(x = fecha, y = y)) +
    geom_line() +
    geom_hline(yintercept = y_intercept, linetype = 2, color = "red", lwd = 0.5) +
    labs(title = title, x = "Fecha", y = "Retornos") +
    theme(plot.title = element_text(color="#15297c", size=14, face="bold.italic" ,hjust=0.5))
}


y_intercept_amzn <- c(arima_amazon$li, arima_amazon$ls)
amzn <- grafico_varianza_constante(amzn_imputed_df,
                                       amzn_imputed_df$amzn_close,
                                       y_intercept_amzn, "Retornos Amazon")
amzn

y_intercept_aapl <- c(arima_apple$li, arima_apple$ls)
aapl <- grafico_varianza_constante(aapl_imputed_df,
                                       aapl_imputed_df$aapl_close,
                                       y_intercept_aapl, "Retornos Apple")
aapl

y_intercept_msft <- c(arima_microsoft$li, arima_microsoft$ls)
msft <- grafico_varianza_constante(msft_imputed_df,
                                       msft_imputed_df$msft_close,
                                       y_intercept_msft, "Retornos Microsoft")
msft

y_intercept_tsla <- c(arima_tesla$li, arima_tesla$ls)
tsla <- grafico_varianza_constante(tsla_imputed_df,
                                       tsla_imputed_df$tsla_close,
                                       y_intercept_tsla, "Retornos Tesla")
tsla
```



**Retornos Acciones 2**
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Modelamiento varianza constante 

y_intercept_meta <- c(arima_meta$li, arima_meta$ls)
meta <- grafico_varianza_constante(meta_imputed_df,
                                       meta_imputed_df$meta_close,
                                       y_intercept_meta, "Retornos Meta")
meta

y_intercept_dis <- c(arima_disney$li, arima_disney$ls)
dis <- grafico_varianza_constante(dis_imputed_df,
                                       dis_imputed_df$dis_close,
                                       y_intercept_dis, "Retornos Disney")
dis

y_intercept_nflx <- c(arima_netflix$li, arima_netflix$ls)
nflx <- grafico_varianza_constante(nflx_imputed_df,
                                       nflx_imputed_df$nflx_close,
                                       y_intercept_nflx, "Retornos Netflix")
nflx

y_intercept_nvda <- c(arima_nvidia$li, arima_nvidia$ls)
nvda <- grafico_varianza_constante(nvda_imputed_df,
                                       nvda_imputed_df$nvda_close,
                                       y_intercept_nvda, "Retornos Nvidia")
nvda
```

## Varianza NO constante

**Retornos Acciones 1**
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Modelamiento varianza NO constante 

grafico_varianza_no_constante <- function(datos, y, li, ls, title) {
  
  # Crear el gráfico utilizando ggplot
  grafico <- ggplot(data = datos, aes(x = fecha, y = y)) +
    geom_line() +
    geom_ribbon(aes(ymin = li, ymax = ls), alpha = 0.4, linetype = 2, col = "red") +
    labs(title = title, x = "Fecha", y = "Retornos") +
    theme(plot.title = element_text(color = "#15297c", size = 14, face = "bold.italic", hjust = 0.5))
  
  return(grafico)
}

amzn_garch <- grafico_varianza_no_constante(amzn_imputed_df,
                                            amzn_imputed_df$amzn_close,                                                    garch_amazon$li,
                                            garch_amazon$ls,"")
amzn_garch

aapl_garch <- grafico_varianza_no_constante(aapl_imputed_df,
                                            aapl_imputed_df$aapl_close,                                                    garch_apple$li,
                                            garch_apple$ls,"Retornos Apple")
aapl_garch

msft_garch <- grafico_varianza_no_constante(msft_imputed_df,
                                            msft_imputed_df$msft_close,                                                    garch_microsoft$li,
                                            garch_microsoft$ls,"Retornos Microsoft")
msft_garch

tsla_garch <- grafico_varianza_no_constante(tsla_imputed_df,
                                            tsla_imputed_df$tsla_close,                                                    garch_tesla$li,
                                            garch_tesla$ls,"Retornos Tesla")
tsla_garch
```

**Retornos Acciones 2**
```{r}
#| echo: false
#| cache: true
#| layout-ncol: 2
#| lightbox: 
#|   group: Modelamiento varianza NO constante

meta_garch <- grafico_varianza_no_constante(meta_imputed_df,
                                            meta_imputed_df$meta_close,                                                    garch_meta$li,
                                            garch_meta$ls,"Retornos Meta")
meta_garch

dis_garch <- grafico_varianza_no_constante(dis_imputed_df,
                                            dis_imputed_df$dis_close,                                                      garch_disney$li,
                                            garch_disney$ls,"Retornos Disney")
dis_garch

nflx_garch <- grafico_varianza_no_constante(nflx_imputed_df,
                                            nflx_imputed_df$nflx_close,                                                    garch_netflix$li,
                                            garch_netflix$ls,"Retornos Netflix")
nflx_garch

nvda_garch <- grafico_varianza_no_constante(nvda_imputed_df,
                                            nvda_imputed_df$nvda_close,                                                    garch_nvidia$li,
                                            garch_nvidia$ls,"Retornos Nvidia")
nvda_garch
```


:::

## Matriz de varianzas y covarianzas

```{r}
#| echo: false
actions_dat_imputed <- Reduce(merge,list(amzn_imputed_df,aapl_imputed_df,
                                         msft_imputed_df,tsla_imputed_df,
                                         meta_imputed_df,dis_imputed_df,
                                         nflx_imputed_df,nvda_imputed_df))

gogmm<-gogarch(actions_dat_imputed[,-1],formula=~garch(1,1))

fecha <- actions_dat_imputed[,1]
```

```{r}
#| echo: false
# Covarianzas a lo largo del tiempo

cova <- ccov(gogmm)

cova<- as.data.frame(cova)

# data frame covarianzas a los largo del tiempo

cova <- cbind(fecha,cova)

# función Gráficos covarianza 

grafico_covarianza <- function(datos, y_aes, y_intercept, titulo){
  
  datos %>%
    ggplot(aes(x=fecha, y=y_aes)) +
    geom_line(size=0.5, color="black") +
    geom_hline(yintercept = y_intercept, linetype = 2, color = "red", lwd = 0.8)+
    ggtitle(titulo) +
    ylab("Covarianza")+
    xlab("Fecha") + 
    theme(plot.title = element_text(color="#15297c", size=9, face="bold.italic", hjust=0.5))
}


cov_amzn_aapl <- grafico_covarianza(cova,cova$`aapl_close & amzn_close`,
                                    1.935960e-04, "Amazon y Apple")

cov_aapl_msft <- grafico_covarianza(cova,cova$`msft_close & aapl_close`,
                                    0.0001975242, "Apple y Microsoft")

cov_amzn_msft <- grafico_covarianza(cova,cova$`msft_close & amzn_close`,
                                    0.0002009561, "Amazon y Microsoft")


#varianza condicional 

vari <- cvar(gogmm)

vari <- as.data.frame(vari) 

vari <- cbind(fecha,vari)

varianza_gogarch <- function(datos, y_aes, ymin, ymax,titulo){
  
  datos %>% 
  ggplot(aes(x = fecha, y = y_aes)) +
  geom_line() +
  geom_ribbon(aes(ymin = ymin, ymax = ymax),
              alpha = 0.4,linetype=2 ,col = "red") +
  labs(title = titulo, x = "Fecha", y = "Retornos")+
  theme(plot.title = element_text(color="#15297c", size=9, face="bold.italic", hjust=0.5))

}

li_amzn_gogarch <- -qnorm(0.975)*sqrt(vari$V.amzn_close)
ls_amzn_gogarch <-  qnorm(0.975)*sqrt(vari$V.amzn_close)

amzn_gogarch <- varianza_gogarch(actions_dat_imputed,
                                     actions_dat_imputed$amzn_close,
                                     li_amzn_gogarch,
                                     ls_amzn_gogarch,
                                     "Amazon")

li_aapl_gogarch <- -qnorm(0.975)*sqrt(vari$V.aapl_close)
ls_aapl_gogarch <-  qnorm(0.975)*sqrt(vari$V.aapl_close)

aapl_gogarch <- varianza_gogarch(actions_dat_imputed,
                                     actions_dat_imputed$aapl_close,
                                 li_aapl_gogarch,
                                 ls_aapl_gogarch,
                                     "Apple")


li_msft_gogarch <- -qnorm(0.975)*sqrt(vari$V.msft_close)
ls_msft_gogarch <-  qnorm(0.975)*sqrt(vari$V.msft_close)

msft_gogarch <- varianza_gogarch(actions_dat_imputed,
                                 actions_dat_imputed$msft_close,
                                 li_msft_gogarch,
                                 ls_msft_gogarch,
                                 "Microsoft")

# GRAFICOS covarianza y varianza 

grid.arrange(amzn_gogarch,cov_amzn_aapl,
             cov_amzn_msft,NULL,aapl_gogarch,
             cov_aapl_msft,NULL,NULL,msft_gogarch,
             ncol=3, nrow=3)

```

## Modelos multivariados GARCH

**Modelo BEKK**

$$
\Sigma_t=\mathbf{A}_0 \mathbf{A}_0^{\prime}+\sum_{l=1}^r \sum_{i=1}^p \mathbf{A}_{i l}\left(\varepsilon_{t-i} \varepsilon_{t-i}^{\prime}\right) \mathbf{A}_{i l}^{\prime}+\sum_{l=1}^r \sum_{j=1}^q \mathbf{B}_{j l} \Sigma_{t-j} \mathbf{B}_{j l}^{\prime}
$$
**Modelo GARCH ortogonal**

El procedimiento para ajustar un modelo GARCH ortogonal es el siguiente:

- Para el conjunto de vectores de series $r_1, r_2,\dots, r_T$ , considere la matriz $Y = [r_1, r_2,\dots, r_T]$.

- Estandarizar la matriz $Y$, restando la media y dividiendo por la desviación típica de cada columna, obteniendo la matriz $X$.

**R:** Con la función "scale()".

**Pyhton:** Se utiliza la clase "StandardScaler()" ,de la librería scikitlearn

- Obtener las matrices de valores propios $A*$ , y de vectores propios $W$, de la matriz de covarianzas y varianzas, la cual está dada por: $\frac{X^TX}{T}$

**R:** Con la función "princomp()"

**Pyhton:** Con la clase "sklearn.decomposition.PCA",de la librería scikitlearn

**Nota**: Recordar que los valores propios asociados están en orden de magnitud decreciente.

- Obtener la matriz de componentes principales, $P$ de dimensiones $(T \times k)$, que se puede escribir como: 
$$\mathbf{P=XW}$$
Con los mismos paquetes que el punto 3.

**Recordar** El primer componente principal explica la mayor cantidad de varianza.

$$P_1=w_{1,1}X_1+w_{1,2}X_2+...+w_{1,T}X_T$$
Con esto se obtuvo una transformación lineal de los datos originales de tal manera que las nuevas series transformadas son *ortogonales y, por lo tanto, tienen correlación cero*.


- Para cada componente ajustar un modelo GARCH univariante para la volatilidad, y generar las matrices diagonales $D_t$, $t = 1, \cdots, T$.

**R:** Con el paquete "rugarch()"

**Pyhton:** Con el paquete "arch"

- Obtenga la matriz de pesos factoriales reescalada $A$, y para cada instante $t$ considere la matriz de covarianzas condicional:
$$\mathbf{V_t = A D_t A'}$$

**R:** Utilizar el operador$\%*\%$. Ejemplo: V_t <- A $\%*\%$ D_t $\%*\%$ t(A)

**Pyhton:** Utilizar el operador "@". Ejemplo: V_t = A@D_t@A^T 

Donde,

$D_t$ matriz diagonal de varianzas condicionales de los componentes principales.

$V_t$ matriz de covarianza variable en el tiempo.

$A$ matriz de los pesos factoriales reescalados.

::: callout-tip
La matriz diagonal $D_t$ de las varianzas de los componentes
principales se estima utilizando un modelo GARCH
::: 




# Portafolio

:::panel-tabset

## Con el modelo GO-GARCH

Para calcular la rentabilidad y el riesgo (desviación típica) del portafolio necesitaremos:

<!-- - Rentabilidad media de los activos. -->
<!-- - Ponderaciones de la cartera. -->
<!-- - Matriz de covarianza predicha un periodo al futuro de todos los activos. -->
<!-- - Ponderaciones aleatorias. -->
<!-- - Primero vamos a calcular la rentabilidad media diaria de cada activo. -->

```{r}
mean_ret <- colMeans(actions_dat_imputed[,-1])
```

```{r}
#| echo: false

kable(mean_ret %>% round(5),
  caption = "Rentabilidad media diaria de cada activo") %>%
   kable_styling(bootstrap_options =form.basic )
```
<!-- A continuación vamos a crear las ponderaciones aleatorias: -->
```{r}
#| echo: false
#| results: hide
set.seed(093)
wts <- runif(n = 8)
print(wts)
```

<!-- La suma de los pesos es: -->
```{r}
#| echo: false
#| results: hide
print(sum(wts))
```

<!-- Hemos creado algunos pesos aleatorios, pero el problema es que su suma es mayor que 1. Podemos solucionarlo como se muestra a continuación: -->
```{r}
#| echo: false
#| results: hide
wts <- wts/sum(wts)
print(wts)
sum(wts)
```

A continuación, realizaremos el cálculo de la matriz de covarianza para estas acciones utilizando el modelo o-goarch. Posteriormente, haremos la predicción de un día para estas acciones y, finalmente, la anualizaremos multiplicando por 252.
```{r}
gogmm<-gogarch(actions_dat_imputed[,-1],formula=~garch(1,1))
```

Realizamos la predicción de la covarianza un periodo al futuro
```{r}
pred <- predict(gogmm,1) 
```

covarianza predicha con gogarch anualizada
```{r}
Cov_gogarch<- (pred@Hf %>% as.data.frame() %>% as.matrix()) *252
```

```{r}
#| echo: false
kable(Cov_gogarch %>% round(4),
  caption = "Matriz de covarianza NO constante") %>%
   kable_styling(bootstrap_options =form.basic )
```

A continuación calcularemos los retornos anualizados del portafolio.
```{r}
port_returns <- (sum(wts * mean_ret) + 1)^252 - 1
port_returns
```


A continuación calcularemos el riesgo de la cartera (desviación estándar). Esta será la desviación estándar anualizada para la cartera. Usaremos álgebra lineal para calcular el riesgo de nuestra cartera.

```{r}
port_risk <- sqrt(t(wts) %*% (Cov_gogarch %*% wts))
port_risk
```

**Sharpe Ratio:** Es una herramienta cuantitativa para evaluar el retorno de una inversión en relación con el riesgo asumido. 

<!-- Un Sharpe ratio mayor a 1 se considera favorable, ya que indica una mayor rentabilidad por unidad de volatilidad. -->


<!-- El Sharpe ratio es una medida que compara el rendimiento de una inversión con su riesgo ajustado. Un Sharpe ratio mayor a 1 se considera favorable, ya que indica una mayor rentabilidad por unidad de volatilidad. Es una herramienta cuantitativa para evaluar el retorno de una inversión en relación con el riesgo asumido. -->

$$\operatorname{Sharpe \ Ratio}=\frac{R_p-R_f}{\sigma_p}$$

$R_p$: Es la rentabilidad esperada del portafolio.
<!-- del cual estamos calculando el sharpe ratio. -->

$R_f$: Es la rentabilidad esperada del activo sin riesgo.

$\sigma_p$: Es la desviación del rendimiento de los activos en cuestión.
<!--  representa la medida de riesgo -->

A continuación, supondremos una tasa libre de riesgo del 0% para calcular el Ratio de Sharpe.
```{r}
sharpe_ratio <- port_returns/port_risk
sharpe_ratio
```

Todo lo que necesitamos ahora es ejecutar este código en 5000 carteras aleatorias. Para ello utilizaremos un bucle for.

<!-- Antes de hacer eso, tenemos que crear vectores vacíos y la matriz para almacenar nuestros valores. -->

```{r}
num_port <- 5000

# Crear una matriz para almacenar los pesos

all_wts <- matrix(nrow = num_port,
                  ncol = 8)

# Crear un vector vacío para almacenar
# los retornos del portafolio

port_returns <- vector('numeric', length = num_port)

# Crear un vector vacío para almacenar
# la desviación estándar del  portafolio

port_risk <- vector('numeric', length = num_port)

# Crear un vector vacío para almacenar
# Sharpe Ratio del portafolio

sharpe_ratio <- vector('numeric', length = num_port)

# A continuación, ejecutemos el ciclo for 5000 veces.

for (i in seq_along(port_returns)) {
  
  wts <- runif(8)
  wts <- wts/sum(wts)
  
  # Almacenar el peso en la matriz
  all_wts[i,] <- wts
  
  # Retorno del portafolio
  
  port_ret <- sum(wts * mean_ret)
  port_ret <- ((port_ret + 1)^252) - 1
  
  # Almacenamiento de los valores de Retorno del Portafolio
  port_returns[i] <- port_ret
  
  
  # Crear y almacenar el riesgo del portafolio
  port_sd <- sqrt(t(wts) %*% (Cov_gogarch  %*% wts))
  port_risk[i] <- port_sd
  
  # Creando y almacenando los Sharpe Ratios  del Portafolio 
  # Suponiendo un 0% de tasa libre de riesgo
  
  sr <- port_ret/port_sd
  sharpe_ratio[i] <- sr
  
}
```

Ya se ha hecho todo el trabajo pesado y ahora podemos crear una tabla de datos para almacenar todos los valores juntos
```{r}
#| echo: false
portfolio_values <- tibble(Return = port_returns,
                           Risk = port_risk,
                           SharpeRatio = sharpe_ratio)

# Convertir la matriz en un tibble y cambiar los nombres de las columnas

all_wts <- tk_tbl(all_wts)

colnames(all_wts) <- colnames(actions_dat_imputed[,-1])

# Combinando todos los valores

portfolio_values <- tk_tbl(cbind(all_wts, portfolio_values))

kable(portfolio_values %>% round(5) %>% head(),
  caption = "Valores del portafolio") %>%
   kable_styling(bootstrap_options =form.basic )

```
Tenemos las ponderaciones en cada activo con el riesgo y la rentabilidad junto con el ratio Sharpe de cada cartera.


A continuación vamos a ver los portafolios más importantes.

- El portafolio de varianza mínima.
- El portafolio de tangencia.

```{r}
min_var <- portfolio_values[which.min(portfolio_values$Risk),]
max_sr <- portfolio_values[which.max(portfolio_values$SharpeRatio),]
```

Vamos a trazar las ponderaciones de cada portafolio.

Primero con el **portafolio de varianza mínima**.

```{r}
#| echo: false
p <- min_var %>%
  gather(amzn_close:nvda_close, key = Asset,
         value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) +
  geom_bar(stat = 'identity') +
  theme_minimal() +
  labs(x = 'Activos', y = 'Pesos', title = "Pesos mínimos del portafolio de de mínima varianza") +
  scale_y_continuous(labels = scales::percent) 


ggplotly(p)
```

A continuación, examinemos el **portafolio de tangencia** o el **portafolio con el mayor ratio sharpe**.
```{r}
#| echo: false
p1 <- max_sr %>%
  gather(amzn_close:nvda_close, key = Asset,
         value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) +
  geom_bar(stat = 'identity') +
  theme_minimal() +
  labs(x = 'Activos', y = 'Pesos', title = "Tangencia Ponderaciones del portafolio") +
  scale_y_continuous(labels = scales::percent) 



ggplotly(p1)
```

Por último, tracemos todos los portafolios aleatorios y visualicemos la frontera eficiente.
```{r}
#| echo: false
p2 <- portfolio_values %>%
  ggplot(aes(x = Risk, y = Return, color = SharpeRatio)) +
  geom_point() +
  theme_classic() +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(x = 'Riesgo anualizado',
       y = 'Rentabilidad anualizada',
       title = "Optimización del portafolio y frontera eficiente") +
  geom_point(aes(x = Risk, y = Return), data = min_var, color = 'red') +
  geom_point(aes(x = Risk, y = Return), data = max_sr, color = 'red') +
  annotate('text', x = 0.265, y = 0.45, label = "Portafolio de Tangencia") +
  annotate('text', x = 0.28, y = 0.16, label = "Portafolio de varianza mínima") +
  annotate(geom = 'segment', x = 0.24, xend = 0.26, y = 0.43, yend = 0.3845, color = 'red', arrow = arrow(type = "open")) +
  annotate(geom = 'segment', x = 0.27, xend = 0.225, y = 0.18, yend = 0.25, color = 'red', arrow = arrow(type = "open"))


ggplotly(p2)
```

## Con varianza constante
```{r}
#| echo: false
cov_cte <- cov(actions_dat_imputed[,-1]) * 252
kable(cov_cte %>% round(4),
  caption = "Matriz de covarianza constante") %>%
   kable_styling(bootstrap_options =form.basic )
```


```{r}
#| echo: false

num_port <- 5000

# Crear una matriz para almacenar los pesos

all_wts <- matrix(nrow = num_port,
                  ncol = 8)

# Crear un vector vacío para almacenar
# los retornos del portafolio

port_returns_cte <- vector('numeric', length = num_port)

# Crear un vector vacío para almacenar
# la desviación estándar del  portafolio

port_risk_cte <- vector('numeric', length = num_port)

# Crear un vector vacío para almacenar
# Sharpe Ratio del portafolio

sharpe_ratio_cte <- vector('numeric', length = num_port)

# A continuación, ejecutemos el ciclo for 5000 veces.

for (i in seq_along(port_returns_cte)) {
  
  wts <- runif(8)
  wts <- wts/sum(wts)
  
  # Almacenar el peso en la matriz
  all_wts[i,] <- wts
  
  # Retorno del portafolio
  
  port_ret <- sum(wts * mean_ret)
  port_ret <- ((port_ret + 1)^252) - 1
  
  # Almacenamiento de los valores de Retorno del Portafolio
  port_returns_cte[i] <- port_ret
  
  
  # Crear y almacenar el riesgo del portafolio
  port_sd <- sqrt(t(wts) %*% (cov_cte  %*% wts))
  port_risk_cte[i] <- port_sd
  
  # Creando y almacenando los Sharpe Ratios  del Portafolio 
  # Suponiendo un 0% de tasa libre de riesgo
  
  sr <- port_ret/port_sd
  sharpe_ratio_cte [i] <- sr
}

```

```{r}
#| echo: false

portfolio_values_cte <- tibble(Return = port_returns_cte,
                           Risk = port_risk_cte,
                           SharpeRatio = sharpe_ratio_cte)

# Convertir la matriz en un tibble y cambiar los nombres de las columnas

all_wts <- tk_tbl(all_wts)

colnames(all_wts) <- colnames(actions_dat_imputed[,-1])

# Combinando todos los valores

portfolio_values_cte <- tk_tbl(cbind(all_wts, portfolio_values_cte))

kable(portfolio_values_cte %>% round(5) %>% head(),
  caption = "Valores del portafolio") %>%
   kable_styling(bootstrap_options =form.basic )
```

Primero con el **portafolio de varianza mínima**.
```{r}
#| echo: false
min_var_cte <- portfolio_values_cte[which.min(portfolio_values_cte$Risk),]
max_sr_cte <- portfolio_values_cte[which.max(portfolio_values_cte$SharpeRatio),]

p3 <- min_var_cte %>%
  gather(amzn_close:nvda_close, key = Asset,
         value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) +
  geom_bar(stat = 'identity') +
  theme_minimal() +
  labs(x = 'Activos', y = 'Pesos', title = "Pesos mínimos del portafolio de de mínima varianza") +
  scale_y_continuous(labels = scales::percent) 


ggplotly(p3)
```

A continuación, examinemos el **portafolio de tangencia** o el **portafolio con el mayor ratio sharpe**.
```{r}
#| echo: false
p4 <- max_sr_cte %>%
  gather(amzn_close:nvda_close, key = Asset,
         value = Weights) %>%
  mutate(Asset = as.factor(Asset)) %>%
  ggplot(aes(x = fct_reorder(Asset,Weights), y = Weights, fill = Asset)) +
  geom_bar(stat = 'identity') +
  theme_minimal() +
  labs(x = 'Activos', y = 'Pesos', title = "Tangencia Ponderaciones del portafolio") +
  scale_y_continuous(labels = scales::percent) 



ggplotly(p4)
```
Por último, tracemos todos los portafolios aleatorios y visualicemos la frontera eficiente.
```{r}
#| echo: false
p5 <- portfolio_values_cte %>%
  ggplot(aes(x = Risk, y = Return, color = SharpeRatio)) +
  geom_point() +
  theme_classic() +
  scale_y_continuous(labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  labs(x = 'Riesgo anualizado',
       y = 'Rentabilidad anualizada',
       title = "Optimización del portafolio y frontera eficiente") +
  geom_point(aes(x = Risk,
                 y = Return), data = min_var_cte, color = 'red') +
  geom_point(aes(x = Risk,
                 y = Return), data = max_sr_cte, color = 'red') 
  # annotate('text', x = 0.20, y = 0.42, label = "Tangency Portfolio") +
  # annotate('text', x = 0.18, y = 0.01, label = "Minimum variance portfolio") +
  # annotate(geom = 'segment', x = 0.14, xend = 0.135,  y = 0.01, 
  #          yend = 0.06, color = 'red', arrow = arrow(type = "open")) +
  # annotate(geom = 'segment', x = 0.22, xend = 0.2275,  y = 0.405, 
  #          yend = 0.365, color = 'red', arrow = arrow(type = "open"))


ggplotly(p5)
```
:::

# VaR (Valor en Riesgo)

El valor en riesgo es una técnica estadística para medir el riesgo financiero de una inversión. Indica la probabilidad (normalmente $1\%$ o $5\%$) de sufrir una determinada pérdida durante un periodo de tiempo (normalmente 1 día, 1 semana o 1 mes). También se le conoce comúnmente como VaR (Value at Risk).


Ventajas del VaR:

- Agrega todo el riesgo de una inversión en un solo número.

- Es una medida de riesgo estandarizada que se puede comparar.


Se utilizarán los pesos obtenidos del portafolio de tangencia para el cálculo del VaR. Además, se emplearán las medias de los retornos y la matriz de varianzas y covarianzas obtenida utilizando el modelo GARCH ortogonal para un periodo futuro.
```{r}
# weights
w <- c(0.0609, 0.319, 0.214, 0.122, 0.163, 0.00845, 0.0225, 0.09)

# means of the return series
mean_ret_var <- c(0.0013508759, 0.0010620252, 0.0012318673, 0.0016341033,
                  0.0010439215, 0.0002849509, 0.0009632546, 0.0022190459)

Cov_gogarch<- (pred@Hf %>% as.data.frame() %>% as.matrix())
```

Para el cálculo del VaR se necesita el rendimiento esperado y el riesgo del portafolio que está dado por:
$$
R_p=\sum_{i=1}^n w_i R_i=\boldsymbol{w}^{\prime} \boldsymbol{R},
$$
donde **R** hace referencia a la media de cada uno de los retornos y **w** son los pesos correspondientes a cada acción.
```{r}
mu_p <- mean_ret_var %*% w 
mu_p
```

$$
\sigma^2_{p}=\boldsymbol{w}^{\prime} \boldsymbol{\Sigma} \boldsymbol{w},
$$
Donde $\boldsymbol{\Sigma}$ hace referencia a la matriz de varianzas y covarianzas predicha un periodo al futuro obtenida con el modelo GARCH ortogonal.
```{r}
var_p <- t(w) %*% Cov_gogarch %*% w
var_p
```


Finalmente el VaR está dado por la siguiente forma:
$$
\text{VaR} = V \times Z \times \sigma \times \sqrt{T}
$$

Donde,

- **V**, representa el valor de la inversión.
- **Z**, es el valor crítico asociado al nivel de confianza deseado. Para un nivel de confianza del 95% o del 99%.
- $\sigma$, es la desviación estándar de los rendimientos de la inversión.
- **T**, es el horizonte temporal, es decir, la duración del periodo considerado.

El VaR calculado con esta fórmula indica la máxima pérdida esperada en un periodo de tiempo específico, con un nivel de confianza dado.

Entonces se calcula el VaR, obteniendo:
```{r}
T <- 252
alpha <-  0.05 
V <- 23995 
Var <-  V*(exp(qnorm(alpha, mean = T*mu_p, sd= sqrt(T*var_p)))-1)
```

```{r}
#| echo: false
sprintf("El Var del portafolio para 252 días es %f dolares",Var)
```
Después de realizar los cálculos necesarios utilizando el software R, se obtiene un VaR con un nivel de confianza $\alpha=0.05$,  para un horizonte temporal de 252 días y una inversión inical de $V=23.995$ USD.  El resultado del cálculo del VaR es de $2476.258$  USD. En términos prácticos, esto significa que existe un 5\% de probabilidad de perder al menos $2476.258$ USD en un período de 252 días.


# Python

[Creación del portafolio en python](https://colab.research.google.com/drive/10LYTXJuzpSAsGqtLX86OaOxdi_0GriOB#scrollTo=HVDhQr5JwJQO)

![](figs/codigo_python.png){fig-align="center" width=50%}

# Referencias

- Peña, D. (2002). Analisis de datos multivariantes, *Cambridge: McGraw-Hill España*.
- Alexander, C. (2000). A primer on the orthogonal GARCH model. *Manuscript ISMA Centre, University of Reading, UK*.
- Bollerslev, T. (1986). Generalized autoregressive conditional heteroscedasticity. *Journal of econometrics, 31(3), 307-327*.
- Minutti, C. (2010). Métodos de optimización en la construcción de portafolios (Doctoral dissertation, Tesis de licenciatura). Universidad Autónoma Chapingo.
- Zivot, E. (2016). Introduction to Computational Finance and Financial Econometrics with R, *Springer*.

